<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OxiDesk{% block title %}{% endblock %}</title>
    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"
        integrity="sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC"
        crossorigin="anonymous"></script>
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/static/css/modern.css">
    <style>
        [x-cloak] {
            display: none !important;
        }

        /* Custom HTMX loading indicator */
        .htmx-indicator {
            opacity: 0;
            transition: opacity 200ms ease-in;
        }

        .htmx-request .htmx-indicator {
            opacity: 1;
        }

        .htmx-request.htmx-indicator {
            opacity: 1;
        }
    </style>
    {% block head %}{% endblock %}
</head>

<body class="bg-oxi-bg text-gray-100 font-sans antialiased h-screen flex flex-col" hx-boost="true" x-data="notificationBell()">
    {% include "partials/toast.html" %}

    <div class="flex h-screen overflow-hidden p-4 gap-4">
        {% include "partials/sidebar.html" %}

        <!-- Main Content -->
        <main class="flex-1 flex flex-col focus:outline-none oxi-glass overflow-hidden h-full">
            <!-- Header with Notification Bell -->
            <div class="flex items-center justify-end gap-4 px-8 py-4 bg-white/5 border-b border-white/5">
                <!-- Availability Status -->
                {% include "partials/availability_status.html" %}

                <!-- Notification Bell -->
                <div class="relative">
                    <button @click="isOpen = !isOpen" class="relative p-2 text-gray-400 hover:text-white transition-colors duration-200 rounded-xl hover:bg-white/5">
                        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                        </svg>
                        <span x-show="unreadCount > 0" x-text="unreadCount"
                            class="absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center text-xs font-bold bg-oxi-accent text-white rounded-full shadow-[0_0_10px_var(--oxi-accent-glow)]"></span>
                    </button>

                    <!-- Notification Dropdown -->
                    {% include "partials/notification_dropdown.html" %}
                </div>
            </div>

            <div class="flex-1 overflow-auto p-8 oxi-fade-in" id="main-content">
                {% block content %}{% endblock %}
            </div>
        </main>
    </div>

    <script>
        function notificationBell() {
            return {
                unreadCount: 0,
                notifications: [],
                isOpen: false,
                eventSource: null,

                async init() {
                    await this.fetchUnreadCount();
                    await this.fetchNotifications();
                    this.connectSSE();
                },

                async fetchUnreadCount() {
                    try {
                        const response = await fetch('/api/notifications/unread-count');
                        if (response.ok) {
                            const data = await response.json();
                            this.unreadCount = data.unread_count || 0;
                        }
                    } catch (error) {
                        console.error('Failed to fetch unread count:', error);
                    }
                },

                async fetchNotifications() {
                    try {
                        const response = await fetch('/api/notifications?limit=10');
                        if (response.ok) {
                            const data = await response.json();
                            this.notifications = data.notifications || [];
                        }
                    } catch (error) {
                        console.error('Failed to fetch notifications:', error);
                    }
                },

                connectSSE() {
                    this.eventSource = new EventSource('/api/notifications/stream');

                    this.eventSource.onmessage = (event) => {
                        try {
                            const notification = JSON.parse(event.data);
                            this.notifications.unshift(notification);
                            this.unreadCount++;
                            this.showToast(notification);
                        } catch (error) {
                            console.error('Failed to parse notification:', error);
                        }
                    };

                    this.eventSource.onerror = (error) => {
                        console.error('SSE connection error:', error);
                        // Reconnect after 5 seconds
                        setTimeout(() => {
                            if (this.eventSource) {
                                this.eventSource.close();
                                this.connectSSE();
                            }
                        }, 5000);
                    };
                },

                async markAsRead(id) {
                    try {
                        const response = await fetch(`/api/notifications/${id}/read`, {
                            method: 'PUT'
                        });
                        if (response.ok) {
                            const notification = this.notifications.find(n => n.id === id);
                            if (notification && !notification.is_read) {
                                notification.is_read = true;
                                this.unreadCount = Math.max(0, this.unreadCount - 1);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to mark notification as read:', error);
                    }
                },

                async markAllAsRead() {
                    try {
                        const response = await fetch('/api/notifications/read-all', {
                            method: 'PUT'
                        });
                        if (response.ok) {
                            this.notifications.forEach(n => n.is_read = true);
                            this.unreadCount = 0;
                        }
                    } catch (error) {
                        console.error('Failed to mark all as read:', error);
                    }
                },

                showToast(notification) {
                    window.dispatchEvent(new CustomEvent('toast', {
                        detail: {
                            message: notification.content || notification.title,
                            type: 'info'
                        }
                    }));
                },

                getNotificationIcon(type) {
                    switch(type) {
                        case 'assignment':
                            return 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z';
                        case 'mention':
                            return 'M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z';
                        default:
                            return 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z';
                    }
                },

                formatTime(timestamp) {
                    const date = new Date(timestamp);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);

                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins}m ago`;

                    const diffHours = Math.floor(diffMins / 60);
                    if (diffHours < 24) return `${diffHours}h ago`;

                    const diffDays = Math.floor(diffHours / 24);
                    return `${diffDays}d ago`;
                }
            };
        }
    </script>
</body>

</html>